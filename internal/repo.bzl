# Copyright Jay Conrod. All rights reserved.

# This file is part of rules_go_simple. Use of this source code is governed by
# the 3-clause BSD license that can be found in the LICENSE.txt file.

"""Repository rules for rules_go_simple.

A repository rule creates a "repo", a named directory containing build files
and source files, usually downloaded from an external dependency. Both of the
repository rules here are used internally by the go module extension.

go_download actually downloads a Go distribution archive and generates a
BUILD.bazel file that can build the standard library and a builder binary.

go_toolchains generates a BUILD.bazel file with all of the toolchain
definitions.

The go module extension declares one go_toolchains repo and multiple
go_download repos (one for each supported platform). Bazel will only materialize
a go_download repo if its toolchain is selected for a build.
"""

_GOOS_TO_CONSTRAINT = {
    "darwin": "@platforms//os:macos",
    "linux": "@platforms//os:linux",
    "windows": "@platforms//os:windows",
}

_GOARCH_TO_CONSTRAINT = {
    "amd64": "@platforms//cpu:x86_64",
    "arm64": "@platforms//cpu:aarch64",
}

def _go_download_impl(ctx):
    # Download the Go distribution.
    ctx.report_progress("downloading")
    ctx.download_and_extract(
        ctx.attr.urls,
        sha256 = ctx.attr.sha256,
        strip_prefix = "go",
    )

    # Add a build file to the repository root directory.
    # We need to fill in some template parameters, based on the platform.
    ctx.report_progress("generating build file")
    os_constraint = _GOOS_TO_CONSTRAINT.get(ctx.attr.goos)
    if os_constraint == None:
        fail("unsupported goos: " + ctx.attr.goos)
    arch_constraint = _GOARCH_TO_CONSTRAINT.get(ctx.attr.goarch)
    if arch_constraint == None:
        fail("unsupported goarch: " + ctx.attr.goarch)
    constraints = [os_constraint, arch_constraint]
    constraint_str = ",\n        ".join(['"%s"' % c for c in constraints])

    substitutions = {
        "{goos}": ctx.attr.goos,
        "{goarch}": ctx.attr.goarch,
        "{exe}": ".exe" if ctx.attr.goos == "windows" else "",
        "{exec_constraints}": constraint_str,
        "{target_constraints}": constraint_str,
    }
    ctx.template(
        "BUILD.bazel",
        ctx.attr._build_tpl,
        substitutions = substitutions,
    )

go_download = repository_rule(
    implementation = _go_download_impl,
    attrs = {
        "urls": attr.string_list(
            mandatory = True,
            doc = "List of mirror URLs where a Go distribution archive can be downloaded",
        ),
        "sha256": attr.string(
            mandatory = True,
            doc = "Expected SHA-256 sum of the downloaded archive",
        ),
        "goos": attr.string(
            mandatory = True,
            values = ["darwin", "linux", "windows"],
            doc = "Host operating system for the Go distribution",
        ),
        "goarch": attr.string(
            mandatory = True,
            values = ["amd64", "arm64"],
            doc = "Host architecture for the Go distribution",
        ),
        "_build_tpl": attr.label(
            default = "//internal:BUILD.bazel.go_download.tpl",
        ),
    },
    doc = "Downloads a standard Go distribution and installs a build file",
)

_TOOLCHAIN_BUILD_HEADER = """# Generated by go_toolchains in @rules_go_simple//internal:repo.bzl

load("@rules_go_simple//:def.bzl", "go_toolchain")
"""

_TOOLCHAIN_BUILD_TEMPLATE = """
toolchain(
    name = "{toolchain_name}",
    exec_compatible_with = [
        {exec_constraints},
    ],
    target_compatible_with = [
        {target_constraints},
    ],
    toolchain = ":{toolchain_name}_impl",
    toolchain_type = "@rules_go_simple//:toolchain_type",
)

go_toolchain(
    name = "{toolchain_name}_impl",
    builder = "{builder}",
    tools = ["{tools}"],
    stdlib = "{stdlib}",
)
"""

def _go_toolchains_impl(ctx):
    lines = [_TOOLCHAIN_BUILD_HEADER]
    for exec_idx, exec_goos_goarch in enumerate(ctx.attr.goos_goarchs):
        repo_name = ctx.attr.repos[exec_idx]
        exec_goos, exec_goarch = exec_goos_goarch.split("_")
        exec_constraints = [
            _GOOS_TO_CONSTRAINT[exec_goos],
            _GOARCH_TO_CONSTRAINT[exec_goarch],
        ]
        exec_constraints_str = ", ".join(['"{}"'.format(c) for c in exec_constraints])
        builder = "@{}//:builder".format(repo_name)
        tools = "@{}//:tools".format(repo_name)
        stdlib = "@{}//:stdlib".format(repo_name)

        for target_goos_goarch in ctx.attr.goos_goarchs:
            target_goos, target_goarch = target_goos_goarch.split("_")
            target_constraints = [
                _GOOS_TO_CONSTRAINT[target_goos],
                _GOARCH_TO_CONSTRAINT[target_goarch],
            ]
            target_constraints_str = ", ".join(['"{}"'.format(c) for c in target_constraints])
            toolchain_name = "exec_{}_target_{}".format(exec_goos_goarch, target_goos_goarch)

            lines.append(_TOOLCHAIN_BUILD_TEMPLATE.format(
                toolchain_name = toolchain_name,
                exec_constraints = exec_constraints_str,
                target_constraints = target_constraints_str,
                builder = builder,
                tools = tools,
                stdlib = stdlib,
            ))

    ctx.file("BUILD.bazel", content = "\n".join(lines))

go_toolchains = repository_rule(
    implementation = _go_toolchains_impl,
    attrs = {
        "repos": attr.string_list(),
        "goos_goarchs": attr.string_list(),
        "_build_tpl": attr.label(
            default = "//internal:BUILD.bazel.go_toolchains.tpl",
        ),
    },
    doc = "Declares Go toolchains for all supported platforms",
)
